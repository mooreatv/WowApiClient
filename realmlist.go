// Copyright 2019 MooreaTv moorea@ymail.com
// All Rights Reserved

// Get your OAUTH_CID and OAUTH_SEC by creating a client on
// https://develop.battle.net/access/clients

package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"time"

	"fortio.org/fortio/fhttp"
	"fortio.org/fortio/log"
)

var (
	regionFlag    = flag.String("region", "us", "Region to query (us,eu,kr,tw,cn)")
	localeFlag    = flag.String("locale", "en_US", "Locale to use (en_US, es_ES, fr_FR,...)")
	justNamesFlag = flag.Bool("names", false, "Just output the names in lua table")
)

func getToken() string {
	cid := os.Getenv("OAUTH_CID")
	if len(cid) == 0 {
		log.Fatalf("Please specify client id as OAUTH_CID env var (https://develop.battle.net/access/clients)")
	}
	csec := os.Getenv("OAUTH_SEC")
	if len(csec) == 0 {
		log.Fatalf("Please specify client secret as OAUTH_SEC env var")
	}
	tokenURL := "https://us.battle.net/oauth/token" // always US even for EU ?
	log.Infof("Getting token from %s...", tokenURL)

	o := fhttp.HTTPOptions{
		URL:               tokenURL,
		DisableFastClient: true,
		FollowRedirects:   true,
		UserCredentials:   cid + ":" + csec,
		ContentType:       "application/x-www-form-urlencoded",
		Payload:           []byte("grant_type=client_credentials"),
	}
	res, data := fhttp.Fetch(&o)
	log.LogVf("code = %d, data=%s", res, fhttp.DebugSummary(data, 512))

	var kv map[string]interface{}

	if err := json.Unmarshal(data, &kv); err != nil {
		log.Fatalf("Unable to parse json result %s: %v", fhttp.DebugSummary(data, 80), err)
	}
	token := kv["access_token"]
	log.Infof("Found token to be %v (in %v)", token, kv)
	return token.(string)
}

type Realm struct {
	Name        string
	Type        string
	Population  string
	Battlegroup string
}

func parseRealmList(data []byte) []Realm {
	type RealmList struct {
		Realms []Realm
	}
	var realmList RealmList
	if err := json.Unmarshal(data, &realmList); err != nil {
		log.Fatalf("Unable to unmarshal json result %s: %v", fhttp.DebugSummary(data, 80), err)
	}
	log.LogVf("parsed: %#v", realmList)
	return realmList.Realms
}

func getRealmList(region, token string) []byte {
	url := fmt.Sprintf("https://%s.api.blizzard.com/wow/realm/status?access_token=%s", region, token)
	log.Infof("Using url %s", url)
	o := fhttp.HTTPOptions{
		URL:               url,
		DisableFastClient: true,
		FollowRedirects:   true,
	}
	res, data := fhttp.Fetch(&o)
	log.LogVf("code = %d, data=%s", res, fhttp.DebugSummary(data, 512))
	return data
}

var header = `-- Realm list generated by https://github.com/mooreatv/WowApiClient
-- go run realmlist.go -names -region %[1]s > Realms_%[1]s.lua
-- on %[2]s
Realms = Realms or {}
Realms.%[1]s = {
`
var footer = `}
-- end of generated realm list for %s region
`

func main() {
	flag.Parse()
	token := getToken()
	region := *regionFlag
	data := getRealmList(region, token)
	outFile := os.Stdout
	if *justNamesFlag {
		realms := parseRealmList(data)
		fmt.Fprintf(outFile, header, region, time.Now().UTC().Format(time.UnixDate))
		for _, r := range realms {
			fmt.Fprintf(outFile, "  \"%s\",\n", r.Name)
		}
		fmt.Fprintf(outFile, footer, region)
		return
	}
	// Pretty print everything:
	var jsonIndented bytes.Buffer
	if err := json.Indent(&jsonIndented, data, "", "  "); err != nil {
		log.Fatalf("Unable to indent json result %s: %v", fhttp.DebugSummary(data, 80), err)
	}
	jsonIndented.WriteTo(outFile)
}
